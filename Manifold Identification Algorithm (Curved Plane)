AXIS_TILES = 5 # Algorithm will divide section into n^2 tiles

from sklearn import linear_model
from numpy import linalg as LA
import sys  # maxint

def toManifoldDF(result):
    return pd.DataFrame({'x': result[0], 'y': result[1], 'z': result[2]})

# MAIN ALGORITHM
def plane(result):
    df= toManifoldDF(result)
    manifold= toManifoldList(result)

    X= df[['x', 'y']]
    Y= df['z']
    regr= linear_model.LinearRegression()
    regr.fit(X, Y)
    main_axis= 'z'
    normal= [regr.coef_[0], regr.coef_[1], -1.0]
    # print(regr.coef_)
    intercept= [0.0, 0.0, regr.intercept_]

    maxCoef= max(math.fabs(regr.coef_[0]), math.fabs(regr.coef_[1]), 1.0)

    if maxCoef == regr.coef_[0]:
        X= df[['y', 'z']]
        Y= df['x']
        regr.fit(X, Y)
        main_axis= 'x'
        intercept= [regr.intercept_, 0.0, 0.0]
        normal= [-1.0, regr.coef_[0], regr.coef_[1]]
    elif maxCoef == regr.coef_[1]:
        X= df[['x', 'z']]
        Y= df['y']
        regr.fit(X, Y)
        main_axis= 'y'
        normal= [regr.coef_[0], -1.0, regr.coef_[1]]
        intercept= [0.0, regr.intercept_, 0.0]

    projection= []
    projDict= {}

    for point in manifold:
        projected= projPlane(point, normal, intercept).tolist()
        projDict[tuple(point.tolist())]= projected
        projection.append(projected)

    encoded= encode(projection, main_axis,intercept)
    convexHull= GrahamScan(encoded).tolist()
    convexHull.append(convexHull[0])
    convexHull= np.array(convexHull)
    boundingBox= minBoundingRect(convexHull)
    boundingBox= decode(boundingBox, main_axis, regr)

    corner= boundingBox[1]
    M= maxNorm(boundingBox[0] - corner, boundingBox[2] - corner)
    m= minNorm(boundingBox[0] - corner, boundingBox[2] - corner)

    tile_matrix= []

    for i in range(AXIS_TILES):
        row= []
        for j in range(AXIS_TILES):
            center= corner + (i + 0.5) * M + (j + 0.5) * m
            tile= Tile(i, j, center)
            row. append(tile)
        tile_matrix.append(row)

    for point in manifold:
        projected= projDict[tuple(point.tolist())]
        sltn= decompose(projected - corner, M, m)
        M_coef= sltn[0]
        m_coef= sltn[1]

        i= int(M_coef * AXIS_TILES)
        j= int(m_coef * AXIS_TILES)
        tile_matrix[i][j].add(point, projected)

    outList= []
    for i in range(AXIS_TILES):
        for j in range(AXIS_TILES):
            if tile_matrix[i][j].getSize() != 0:
                point= tile_matrix[i][j].getCenter() + tile_matrix[i][j].getR()
                outList.append(point)

    return np.array(outList)

def encode(projection, main_axis, intercept):
    encoded= []

    for point in projection:
        projected2= projPlane(np.array(point), np.array(intercept), np.array([0, 0, 0])).tolist()

        if main_axis == 'x':
            encoded.append([projected2[1], projected2[2]])
        elif main_axis == 'y':
            encoded.append([projected2[0], projected2[2]])
        else:
            encoded.append([projected2[0], projected2[1]])

    return encoded

def decode(coordinates, main_axis, regr):
    decoded= []
    memory= regr.predict(pd.DataFrame(coordinates))

    for i in range(size(coordinates)):
        if main_axis == 'x':
            point= [memory[i], coordinates[i][0], coordinates[i][1]]
        elif main_axis == 'y':
            point= [coordinates[i][0], memory[i], coordinates[i][1]]
        else:
            point= [coordinates[i][0], coordinates[i][1], memory[i]]
        decoded.append(point)

    return np.array(decoded)

# Return point is contained in rectangle
# Rectangle is a np.array of 4 co-ordinates. Precondition: adjacent entries in rectangle are also geometrically
# adjacent
def contained(point, rectangle):
    M= max()

# Calculates the perpendicular distance between point3 and a line passing through point1 and point2.
# Precondition: all entries are np.array
def normalDist(point1, point2, point3):
    return np.norm(np.cross((point2 - point1), (point1 - point3))) / np.norm(point2 - point1)

def maxNorm(vector1, vector2):
    return vector1 if LA.norm(vector1) > LA.norm(vector2) else vector2

def minNorm(vector1, vector2):
    return vector1 if LA.norm(vector1) < LA.norm(vector2) else vector2

# Express vector as a linear combination of base1 and base2
# Precondition: base1 and base2 are independent np.array and vector is in span(base1, base2)
def decompose(vector, base1, base2):
    A= np.array([base1.tolist(), base2.tolist(), np.cross(base1, base2).tolist()])
    A= np.transpose(A)
    b= vector

    return np.linalg.solve(A, b)


# Represents a tile (aka sub-rectangle) on the minimum bounding rectangle
class Tile(object):
    def __init__(self, MID, mID, center):
        self._MID= MID
        self._mID= mID
        self._points= []
        self._center= center
        self._size= 0
        self._r= 0

    def __repr__(self):
        if self._size == 0:
            return "empty tile, ID: " + str(self._MID) + str(self._mID)

        return "Tile ID: " + str(self._MID) + str(self._mID) + " size: " + str(self._size) + " r: " + str(self._r)

    def getSize(self):
        return self._size

    def getCenter(self):
        return self._center

    def add(self, point, projection):
        self._points.append(point)
        self._r= (self._r * self._size + (point - projection)) / (self._size + 1)
        self._size= self._size + 1

    def getR(self):
        return self._r


# Function to know if we have a CCW turn
# Author: Rodolfo Ferro (ferro@cimat.mx)
def RightTurn(p1, p2, p3):
    if (p3[1]-p1[1])*(p2[0]-p1[0]) >= (p2[1]-p1[1])*(p3[0]-p1[0]):
        return False
    return True

# Author: Rodolfo Ferro (ferro@cimat.mx)
def GrahamScan(P):
    P.sort() # Sort the set of points
    L_upper = [P[0], P[1]] # Initialize upper part
    # Compute the upper part of the hull
    for i in range(2,len(P)):
        L_upper.append(P[i])
        while len(L_upper) > 2 and not RightTurn(L_upper[-1],L_upper[-2],L_upper[-3]):
            del L_upper[-2]
    L_lower = [P[-1], P[-2]] # Initialize the lower part
    # Compute the lower part of the hull
    for i in range(len(P)-3,-1,-1):
        L_lower.append(P[i])
        while len(L_lower) > 2 and not RightTurn(L_lower[-1],L_lower[-2],L_lower[-3]):
            del L_lower[-2]
    del L_lower[0]
    del L_lower[-1]
    L = L_upper + L_lower # Build the full hull
    return np.array(L)

# Copyright (c) 2013, David Butterworth, University of Queensland
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Willow Garage, Inc. nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

def minBoundingRect(hull_points_2d):
    #print "Input convex hull points: "
    #print hull_points_2d

    # Compute edges (x2-x1,y2-y1)
    edges = np.zeros( (len(hull_points_2d)-1,2) ) # empty 2 column array
    for i in range( len(edges) ):
        edge_x = hull_points_2d[i+1,0] - hull_points_2d[i,0]
        edge_y = hull_points_2d[i+1,1] - hull_points_2d[i,1]
        edges[i] = [edge_x,edge_y]
    #print "Edges: \n", edges

    # Calculate edge angles   atan2(y/x)
    edge_angles = np.zeros( (len(edges)) ) # empty 1 column array
    for i in range( len(edge_angles) ):
        edge_angles[i] = math.atan2( edges[i,1], edges[i,0] )
    #print "Edge angles: \n", edge_angles

    # Check for angles in 1st quadrant
    for i in range( len(edge_angles) ):
        edge_angles[i] = abs( edge_angles[i] % (math.pi/2) ) # want strictly positive answers
    #print "Edge angles in 1st Quadrant: \n", edge_angles

    # Remove duplicate angles
    edge_angles = np.unique(edge_angles)
    #print "Unique edge angles: \n", edge_angles

    # Test each angle to find bounding box with smallest area
    min_bbox = (0, sys.maxsize, 0, 0, 0, 0, 0, 0) # rot_angle, area, width, height, min_x, max_x, min_y, max_y
    # print "Testing", len(edge_angles), "possible rotations for bounding box... \n"
    for i in range( len(edge_angles) ):

        # Create rotation matrix to shift points to baseline
        # R = [ cos(theta)      , cos(theta-PI/2)
        #       cos(theta+PI/2) , cos(theta)     ]
        R = np.array([ [ math.cos(edge_angles[i]), math.cos(edge_angles[i]-(math.pi/2)) ], [ math.cos(edge_angles[i]+(math.pi/2)), math.cos(edge_angles[i]) ] ])
        #print "Rotation matrix for ", edge_angles[i], " is \n", R

        # Apply this rotation to convex hull points
        rot_points = np.dot(R, np.transpose(hull_points_2d) ) # 2x2 * 2xn
        #print "Rotated hull points are \n", rot_points

        # Find min/max x,y points
        min_x = np.nanmin(rot_points[0], axis=0)
        max_x = np.nanmax(rot_points[0], axis=0)
        min_y = np.nanmin(rot_points[1], axis=0)
        max_y = np.nanmax(rot_points[1], axis=0)
        #print "Min x:", min_x, " Max x: ", max_x, "   Min y:", min_y, " Max y: ", max_y

        # Calculate height/width/area of this bounding rectangle
        width = max_x - min_x
        height = max_y - min_y
        area = width*height
        #print "Potential bounding box ", i, ":  width: ", width, " height: ", height, "  area: ", area

        # Store the smallest rect found first (a simple convex hull might have 2 answers with same area)
        if (area < min_bbox[1]):
            min_bbox = ( edge_angles[i], area, width, height, min_x, max_x, min_y, max_y )
        # Bypass, return the last found rect
        #min_bbox = ( edge_angles[i], area, width, height, min_x, max_x, min_y, max_y )

    # Re-create rotation matrix for smallest rect
    angle = min_bbox[0]
    R = np.array([ [ math.cos(angle), math.cos(angle-(math.pi/2)) ], [ math.cos(angle+(math.pi/2)), math.cos(angle) ] ])
    #print "Projection matrix: \n", R

    # Project convex hull points onto rotated frame
    proj_points = np.dot(R, np.transpose(hull_points_2d) ) # 2x2 * 2xn
    #print "Project hull points are \n", proj_points

    # min/max x,y points are against baseline
    min_x = min_bbox[4]
    max_x = min_bbox[5]
    min_y = min_bbox[6]
    max_y = min_bbox[7]
    #print "Min x:", min_x, " Max x: ", max_x, "   Min y:", min_y, " Max y: ", max_y

    # Calculate center point and project onto rotated frame
    center_x = (min_x + max_x)/2
    center_y = (min_y + max_y)/2
    center_point = np.dot( [ center_x, center_y ], R )
    #print "Bounding box center point: \n", center_point

    # Calculate corner points and project onto rotated frame
    corner_points = np.zeros( (4,2) ) # empty 2 column array
    corner_points[0] = np.dot( [ max_x, min_y ], R )
    corner_points[1] = np.dot( [ min_x, min_y ], R )
    corner_points[2] = np.dot( [ min_x, max_y ], R )
    corner_points[3] = np.dot( [ max_x, max_y ], R )
    #print "Bounding box corner points: \n", corner_points

    return corner_points
